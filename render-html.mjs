import fs from 'node:fs/promises';
import { escape as escapeHtml, min } from 'lodash-es';
import { minify as minifyHtml } from 'html-minifier-terser';

const intFormatter = new Intl.NumberFormat('en', {
	maximumFractionDigits: 0,
});
const formatInt = (number) => {
	return intFormatter.format(number);
};
const deltaFormatter = new Intl.NumberFormat('en', {
	signDisplay: 'exceptZero',
});
const formatDelta = (number, options = {}) => {
	const invert = options.invert;
	if (invert) {
		number = -number;
	}
	const delta = deltaFormatter.format(number);
	const isNeutral = number === 0 || number === null;
	const isNegativeNumber = number < 0;
	const isPositiveResult = !isNegativeNumber;
	return `<span class="${isNeutral ? 'neutral' : (isPositiveResult ? 'good' : 'bad')}">${delta}</span>`;
};

const renderHtml = (embellished) => {
	const output = [
		`<p>Last updated on <time>${escapeHtml(embellished.meta.updated)}</time>.`,
	];
	const table = ['<div class="table-wrapper"><table><thead><tr><th>Date<th colspan=2>Level<th colspan=2>Base damage &amp; healing<th colspan=2>Experience<th colspan=2>Rank<tbody>'];
	for (const entry of embellished.history) {
		table.push(`
			<tr>
				<th scope=row>${escapeHtml(entry.date)}
					<td title="${escapeHtml(formatInt(entry.experienceUntilNextLevel))} xp (${100 - entry.progressWithinLevel}%) until the next level">${escapeHtml(formatInt(entry.level))}<small>.${escapeHtml(String(entry.progressWithinLevel).padStart(2, '0'))}</small> <progress max="100" value="${entry.progressWithinLevel}"></progress>
					<td>${formatDelta(entry.levelDelta)}
					<td>${escapeHtml(formatInt(entry.baseValue))}
					<td>${formatDelta(entry.baseValueDelta)}
					<td>${escapeHtml(formatInt(entry.experience))}
					<td>${formatDelta(entry.experienceDelta)}
					<td>${escapeHtml(entry.rank)}
					<td>${formatDelta(entry.rankDelta, {invert: true})}
		`);
	}
	const meta = embellished.meta;
	table.push(`
		<tfoot>
			<tr>
				<th scope="row">${escapeHtml(formatInt(meta.days))} days
				<td colspan="2">${formatDelta(meta.levelDelta)} levels
					<span class="extra">≈ ${escapeHtml(meta.levelsPerDay.toFixed(2))} levels per day</span>
					<span class="extra">≈ ${escapeHtml(Math.ceil(meta.daysUntilNextBaseBreakpointLevelBasedOnLevelsPerDay))} days until level ${escapeHtml(formatInt(meta.nextBaseBreakpointLevel))}</span>
					<span class="extra">≈ ${escapeHtml(Math.ceil(meta.daysUntilNextMilestoneLevelBasedOnLevelsPerDay))} days until level ${escapeHtml(formatInt(meta.nextMilestoneLevel))}</span>
				<td colspan="2">${formatDelta(meta.baseValueDelta)} base damage &amp; healing
					<span class="extra">≈ an improvement of ${formatDelta(meta.baseValuePercentageIncrease)}%</span>
					<span class="extra">next breakpoint at level ${escapeHtml(formatInt(meta.nextBaseBreakpointLevel))}</span>
				<td colspan="2">${formatDelta(meta.experienceDelta)} experience
					<span class="extra">≈ ${escapeHtml(formatInt(meta.experiencePerDay))} experience per day</span>
					<span class="extra">≈ ${escapeHtml(Math.ceil(meta.daysUntilNextBaseBreakpointLevelExperienceBasedOnExperiencePerDay))} days until
						<span title="Level ${escapeHtml(formatInt(meta.nextBaseBreakpointLevel))} is the next base value breakpoint level at which base damage and healing increases to ${escapeHtml(formatInt(meta.nextBaseValue))}. It requires a total of ${escapeHtml(formatInt(meta.nextBaseBreakpointLevelExperience))} experience — just ${escapeHtml(formatInt(meta.nextBaseBreakpointLevelExperienceDelta))} experience to go!">level ${escapeHtml(formatInt(meta.nextBaseBreakpointLevel))}</span>
					</span>
					<span class="extra">≈ ${escapeHtml(Math.ceil(meta.daysUntilNextMilestoneLevelExperienceBasedOnExperiencePerDay))} days until
					<span title="Level ${escapeHtml(formatInt(meta.nextMilestoneLevel))} requires a total of ${escapeHtml(formatInt(meta.nextMilestoneLevelExperience))} experience — just ${escapeHtml(formatInt(meta.nextMilestoneLevelExperienceDelta))} experience to go!">level ${escapeHtml(formatInt(meta.nextMilestoneLevel))}</span>
				</span>
				<td colspan="2">${formatDelta(meta.rankDelta, {invert: true})} ranks
	`);
	table.push('</table></div>');
	output.push(table.join(''));
	const html = output.join('');
	return html;
};

export const updateHtml = async (embellished) => {
	const htmlTemplate = await fs.readFile('./templates/index.html', 'utf8');
	const html = htmlTemplate.toString()
		.replace('%%%DATA%%%', renderHtml(embellished));
	const minifiedHtml = await minifyHtml(html, {
		collapseBooleanAttributes: true,
		collapseInlineTagWhitespace: false,
		collapseWhitespace: true,
		conservativeCollapse: true,
		decodeEntities: true,
		html5: true,
		includeAutoGeneratedTags: false,
		minifyCSS: true,
		minifyJS: true,
		preserveLineBreaks: false,
		preventAttributesEscaping: true,
		removeAttributeQuotes: true,
		removeComments: true,
		removeEmptyAttributes: true,
		removeEmptyElements: false,
		removeOptionalTags: false,
		removeRedundantAttributes: true,
		removeTagWhitespace: false,
		sortAttributes: true,
		sortClassName: true,
	});
	await fs.writeFile('./dist/index.html', minifiedHtml);
};

